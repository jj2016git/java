# java泛型

## 来龙去脉

### 为什么jdk 1.5之前没有泛型？

- C++中泛型T是占位符，具体调用时T会被具体类型取代
- java中所有类型都是Object子类，使用时，可以将Object强转为目标类型。因此，java设计者早期认为泛型是没有必要的。

### 为什么jdk 1.5推出了泛型

- 编译期检查
- 减少不安全的类型强转

### jdk 1.5泛型设计思路

- 编译期，提供类型检查
- 运行期，将泛型T，通配符?全都擦除成Object或T的上限类型

	- primitive类型不是Object的子类，这就是“type argument cannot be primitive type”的原因

- 运行期，为泛型返回值提供类型强转
- 为解决泛型在使用多态时出现的问题，提供bridge方法

## generic type

### 泛型参数命名规范

- E: element, 多用在集合中
- T: type
- 多个泛型参数时，可用T, S, U, V
- K: key, V: value, 多用在map

### generic type实例化

- 推荐写法

  - `List<String> fooList = new ArrayList<String>()`
  - `List<String> fooList = new ArrayList<>()`

- 不推荐

  - `List<String> fooList = new ArrayList();`

- raw type

  - 没有泛型参数的泛型类/接口
  - e.g. new ArrayList()

  ```java
  // 编译通过：使用raw type绕过了编译期类型检查
  // 出于兼容jdk1.5之前代码的考虑，java允许但不支持使用raw type
  Box<String> b1 = new Box(1);
  
  // 编译错误：cannot infer arguments.
  // java编译器同时通过入参和返回值推断泛型的真实类型
  Box<String> b2 = new Box<>(0);
  
  // 编译错误：Box<String> cannot be applied to int
  Box<String> b3 = new Box<String>(0);
  ```

## 泛型方法

### 方法定义

### 方法调用

- 调用时一般不需要指定泛型具体类型

## 有界的类型参数`<T extends SuperType>`

### 用途

- 在泛型类型实例化时，增加类型约束。e.g. `<T extends Number>`, T只能是Number及其子类
- e.g `<T extends Number>`, T类型变量val可以调用Number的方法

### 多重界限

- `<T extends Class1 & Interface1 & Interface 2 ...>`
- 等同于`class T extends Class1 implements interface1, interface2, ... `

## 类型通配符?

### what?

- 无界限通配符`<?>`
- 上限通配符`<? extends SuperType>`
- 下限通配符`<? super SubType>`

### how?

- 作为parameter

- 作为field

- 作为local variable

- 作返回类型（不建议）

  ```java
  public class BoundedWildcardDemo {
      public static void main(String[] args) {
          BoundedWildcardDemo demo = new BoundedWildcardDemo();
  
          // local variable
          List<? extends Number> numbers = Arrays.asList(1, 2, 3);
          demo.setNumbers(numbers);
          demo.getNumbers().forEach(System.out::println);
      }
  
      // field
      private List<? extends Number> numbers;
  
      // return type
      public List<? extends Number> getNumbers() {
          return numbers;
      }
  
      // parameter
      public void setNumbers(List<? extends Number> numbers) {
          this.numbers = numbers;
      }
  }
  ```

  

### Java: bounded wildcards or bounded type parameter?

[]: https://stackoverflow.com/questions/3486689/java-bounded-wildcards-or-bounded-type-parameter	"什么时候用上限通配符，什么时候用上限类型"

- bounded wildcard适用场景

	- lower bounded，e.g. <? super SubType>

- bounded type parameter适用场景

	- T有多个上限，e.g. <T extends A & B & C>

### 如何使用通配符

- 方法参数分类

	- IN参数：为方法提供数据
	- OUT参数：方法向参数中写入数据
	- IN & OUT参数

- 使用准则

	- IN参数可使用<? extends SuperType>
	- OUT参数可用<? super SubType>
	- IN & OUT参数不适用wildcard
	- IN参数只需要使用Object类的方法时，可用<?>
	- IN参数涉及的操作与泛型类型无关时，可用<?>，如list.clear()

## 泛型继承

![](D:\github\images\generics-subtypeRelationship.gif)

![](D:\github\images\generics-wildcardSubtyping.gif)

## 类型推断

- java编译器根据调用参数、目标类型、返回参数类型推断出最具体的泛型参数值

### wildcard capture



## 类型擦写

- java运行期，将泛型类型擦除成Object或上限类型。

  - 保证运行期实现的向后兼容

- java运行期，为泛型方法添加必要的类型转换

- java运行期，为避免泛型多态引发的方法重载问题，自动为子类生成桥接方法

  ```java
  class Node<T> {
  
      public T data;
  
      public Node(T data) {
          this.data = data;
      }
  
      public void setData(T data) {
          System.out.println("Node.setData");
          this.data = data;
      }
  }
  
  /**
   * type erasure后的Node类
   */
  class Node {
  
      public Object data;
  
      public Node(Object data) {
          this.data = data;
      }
  
      public void setData(Object data) {
          System.out.println("Node.setData");
          this.data = data;
      }
  }
  
  class MyNode extends Node<Integer> {
      public MyNode(Integer data) {
          super(data);
      }
  
      /*
      // Bridge method generated by the compiler
      public void setData(Object data) {
          setData((Integer) data);
      }
      */
  
      public void setData(Integer data) {
          System.out.println("MyNode.setData");
          super.setData(data);
      }
  }
  ```

  